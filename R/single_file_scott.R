Sys.setenv("PKG_CXXFLAGS"="-std=c++11")

#' Fix prepare indels
#'
#' @param name TO BE ADDED
#' @return function TO BE ADDED
#' @export
fix_prepare_indels <- function(name){
  name <- 'prepare.indel.df_tabversion'
  prepare_fixed <- get(name,asNamespace('signature.tools.lib'))
  b <- as.character(body(prepare_fixed))
  body(prepare_fixed)[2] <- parse(text=gsub('max.position \\+ 1','ifelse(indel.type=="I",min.position,max.position)\\+ 1',
                                            gsub('(indel.length) ([-\\+]) 25','2*indel.length \\2 60',b[2])))
  environment(prepare_fixed) <- asNamespace('signature.tools.lib')
  assignInNamespace(name,prepare_fixed,ns='signature.tools.lib')
  return(NULL)
}

#' Fix load indels
#'
#' @param name TO BE ADDED
#' @return function TO BE ADDED
#' @export
fix_load_indels <- function(name){
  prepfunc <- get(name,asNamespace('signature.tools.lib'))
  b <- body(prepfunc)
  final_line <- length(b)
  body(prepfunc)[c(2,4,(final_line-2):(final_line))] <-
    c(parse(text=gsub('paste0\\(c','paste0("chr",c',gsub('1000genomes\\.hs37d5','UCSC.hg19',as.character(b[2])))),
      expression(message("")),
      parse(text=gsub('*.+','message("")',as.character(b[(final_line-2):(final_line-1)]))),
      expression(return(cbind(indel.data[,!(colnames(indel.data) %in% colnames(indel.df)),drop=F],indel.df))))

  return(prepfunc)
}



#' Prepare indels sequence context information for classification
#'
#' @param indels A indel list. Columns include: "Sample","chr", "position", "REF", "ALT"
#' @param sampleID Cohort name
#' @param genome.v : "hg19", "hg38"
#' @return Extended indel list with 5' and 3' sequence information
#' @export
prepare_indels <- function(indels,sampleID,genome.v){
  ## Adapt the preparation functions by excising the mhcaller
  if(is.character(indels)==TRUE){
    fix_prepare_indels('prepare.indel.df')
    prepfunc <- fix_load_indels('vcfToIndelsClassification')
  }else if(is.data.frame(indels)==TRUE){
    fix_prepare_indels('prepare.indel.df_tabversion')
    prepfunc <- fix_load_indels('tabToIndelsClassification')
  }else{
    stop('Provide either a path to a vcf file or a tab file with chr, position, REF, ALT')
  }
  message("Indel-specific preps")
  df <- prepfunc(indels,sampleID = sampleID,genome.v = genome.v)
  factors <- sapply(df,is.factor)
  df[factors] <- lapply(df[factors],as.character)
  ## Filter out non-computable indels (non ATGCU,MT/M chr, or SNVs (REF/ALT) = 1bp)
  filter <- !(nchar(df$ref)==1 & nchar(df$alt)==1) &
    (grepl('[^ATGCU]',df$ref)==F & grepl('[^ATGCU]',df$alt)==F) &
    !grepl('MT|M',df$chr)
  df <- df[filter,,drop=F]
  ## Add 'pyr' designations
  df$slice3_pyr <- df$slice3
  df$slice5_pyr <- df$slice5
  df$change_pyr <- df$change
  ## change Pyr bases
  pyr_bases <- c('T'='A','C'='G') ## For each single basepair change, consider the opposite strand, and group in order to increase signal (i.e A/T, G/C)
  for(i in seq_along(pyr_bases)){
    cur_base <- df$change == pyr_bases[i]
    df[cur_base,'change_pyr'] <- names(pyr_bases)[i]
    df[cur_base,'slice5_pyr'] <- as.character(Biostrings::reverseComplement(Biostrings::DNAStringSet(df$slice3[cur_base])))
    df[cur_base,'slice3_pyr'] <- as.character(Biostrings::reverseComplement(Biostrings::DNAStringSet(df$slice5[cur_base])))
  }
  return(df)
}

#' Segment indels types for classification
#'
#' @param df An extended indel list generated by prepare_indels().
#' @return Extended indel list with 5' and 3' sequence information
#' @export
segment_indels <- function(df){
  if(!all(c('change','slice3','indel.type') %in% colnames(df))){
    warning('Need change, slice3, and indel.type')
    stop(call. = F)
  }
  if(any(c('unit','prime3_rep','internal_rep','spacer') %in% colnames(df))){
    df <- df[,!(colnames(df) %in% c('unit','unit_length','internal_rep','internal_reps','spacer','spacer_length','prime3_rep','prime3_reps'))]
  }
  message("Running segmentation")
  df <- cbind(df,get('segment',envir = .GlobalEnv)(df$change,df$slice3))
  ## Modified readout values:
  df$internal_coverage=df$unit_length*(df$internal_reps+1)
  ## define original reps
  df$original_reps=ifelse(df$indel.type=='I',df$prime3_reps,
                          ifelse(df$spacer_length==0,
                                 df$internal_reps+1+df$prime3_reps,
                                 df$prime3_reps))
  return(df)
}

###### code ends








